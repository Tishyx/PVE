<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rogue DPS Simulator Professional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e8e8e8;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
            background: linear-gradient(90deg, transparent, rgba(255,215,0,0.1), transparent);
            border-bottom: 2px solid rgba(255,215,0,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255,215,0,0.5);
            letter-spacing: 2px;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Panels */
        .panel {
            background: rgba(15,20,40,0.95);
            border: 1px solid rgba(255,215,0,0.2);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .panel h3 {
            color: #ffd700;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,215,0,0.2);
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Combat Area */
        .combat-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            min-height: 600px;
        }

        /* Target Dummy */
        .target-dummy {
            position: relative;
            margin-top: 30px;
            width: 200px;
            height: 300px;
        }

        .dummy-health-container {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            width: 220px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #333;
            border-radius: 6px;
            padding: 3px;
        }

        .dummy-health-bar {
            height: 20px;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 3px;
            transition: width 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }

        .dummy-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .dummy-model {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #654321, #8b4513);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            position: relative;
            transition: all 0.1s;
        }

        .dummy-model.hit {
            animation: dummyHit 0.2s;
        }

        @keyframes dummyHit {
            0%, 100% { transform: scale(1) rotate(0); }
            25% { transform: scale(1.05) rotate(-2deg); }
            75% { transform: scale(1.05) rotate(2deg); }
        }

        .dummy-head {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 70px;
            background: #d4a574;
            border-radius: 50%;
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.3);
        }

        /* Player Resources */
        .player-resources {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
        }

        .resource-bar {
            margin-bottom: 10px;
        }

        .energy-container {
            background: rgba(0,0,0,0.8);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 3px;
            position: relative;
        }

        .energy-bar {
            height: 30px;
            background: linear-gradient(90deg, #ffeb3b, #ffc107);
            border-radius: 4px;
            transition: width 0.1s linear;
            box-shadow: 0 0 20px rgba(255,235,59,0.5);
        }

        .energy-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #000;
            text-shadow: 0 0 3px rgba(255,255,255,0.8);
        }

        /* Combo Points */
        .combo-points-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .combo-point {
            width: 30px;
            height: 30px;
            background: #333;
            border: 2px solid #555;
            border-radius: 50%;
            transition: all 0.3s;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .combo-point.active {
            background: radial-gradient(circle, #ff6b6b, #ff4444);
            border-color: #ff9999;
            box-shadow: 0 0 15px #ff4444, inset 0 0 10px rgba(255,255,255,0.3);
            animation: comboPulse 0.5s;
        }

        @keyframes comboPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Buff Duration Bar */
        .buff-duration-bar-container {
            margin-top: 15px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #555;
            border-radius: 6px;
            padding: 2px;
            position: relative;
            height: 18px;
        }

        .buff-duration-bar {
            height: 100%;
            background: linear-gradient(90deg, #89f7fe, #66a6ff);
            border-radius: 4px;
            transition: width 0.1s linear;
            box-shadow: 0 0 15px rgba(102, 166, 255, 0.5);
        }

        .buff-duration-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Action Bar */
        .action-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 15px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9), rgba(20,20,40,0.9));
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 10px;
        }

        .ability-slot {
            position: relative;
            width: 60px;
            height: 60px;
            border: 2px solid #444;
            border-radius: 8px;
            background: linear-gradient(135deg, #2a2a3e, #1a1a2e);
            cursor: pointer;
            overflow: hidden;
            transition: all 0.2s;
        }

        .ability-slot:hover:not(.on-cooldown):not(.no-resources) {
            border-color: #ffd700;
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(255,215,0,0.4);
        }

        .ability-slot.activated {
            animation: abilityFlash 0.3s;
        }

        @keyframes abilityFlash {
            0%, 100% { box-shadow: 0 0 0 rgba(255,255,255,0); }
            50% { box-shadow: 0 0 30px rgba(255,255,255,0.8); }
        }

        .ability-icon {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: #ffd700;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8);
        }

        .ability-slot.on-cooldown .ability-icon {
            filter: grayscale(100%) brightness(0.5);
        }

        .ability-slot.no-resources {
            border-color: #ff4444;
            opacity: 0.6;
        }

        .cooldown-sweep {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            pointer-events: none;
        }

        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            pointer-events: none;
        }

        .ability-hotkey {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 11px;
            color: #ffeb3b;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
        }

        .ability-cost {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 11px;
            color: #80dfff;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
        }

        /* GCD Indicator */
        .gcd-indicator {
            position: absolute;
            bottom: -5px;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            border-radius: 2px;
            transition: width linear;
        }

        /* Ability Tooltip */
        .ability-tooltip {
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            width: 220px;
            padding: 10px;
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 6px;
            color: #ccc;
            font-size: 13px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 10;
        }

        .ability-slot:hover .ability-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .tooltip-header {
            color: #ffd700;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: #80dfff;
            margin-bottom: 8px;
        }

        .tooltip-desc {
            color: #a0a0a0;
            font-size: 0.9em;
        }

        /* Buffs & Debuffs */
        .buffs-container {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }

        .buff-icon {
            width: 40px;
            height: 40px;
            border: 2px solid #00ff00;
            border-radius: 6px;
            background: rgba(0,255,0,0.2);
            position: relative;
            animation: buffPulse 2s infinite;
        }

        @keyframes buffPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0,255,0,0.5); }
            50% { box-shadow: 0 0 20px rgba(0,255,0,0.8); }
        }

        .buff-duration {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #00ff00;
            font-weight: bold;
            background: rgba(0,0,0,0.8);
            padding: 0 4px;
            border-radius: 3px;
        }

        /* Floating Combat Text */
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translate(-50%, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150px) scale(0.8);
            }
        }

        .damage-normal {
            color: #ffffff;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .damage-crit {
            color: #ff4444;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255,68,68,0.8), 2px 2px 4px rgba(0,0,0,0.9);
            animation: floatUp 2s ease-out forwards, critBurst 0.3s;
        }

        @keyframes critBurst {
            0% { transform: translate(-50%, 0) scale(1.5); }
            100% { transform: translate(-50%, 0) scale(1); }
        }

        .damage-yellow {
            color: #ffeb3b;
            font-size: 28px;
            text-shadow: 0 0 15px rgba(255,235,59,0.7), 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Combat Log */
        .combat-log {
            height: 400px;
            overflow-y: auto;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }

        .log-entry {
            padding: 4px 8px;
            margin-bottom: 2px;
            border-left: 3px solid #333;
            background: rgba(255,255,255,0.02);
            transition: all 0.2s;
        }

        .log-entry:hover {
            background: rgba(255,255,255,0.05);
        }

        .log-entry.crit {
            border-left-color: #ff4444;
            background: rgba(255,68,68,0.1);
            font-weight: bold;
        }

        .log-entry.ability {
            border-left-color: #ffeb3b;
        }

        .log-entry.buff {
            border-left-color: #00ff00;
        }

        .log-timestamp {
            color: #888;
            margin-right: 10px;
        }

        /* DPS Meter */
        .dps-display {
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,215,0,0.05));
            border: 1px solid rgba(255,215,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .dps-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #ffd700;
            text-align: center;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .dps-label {
            text-align: center;
            color: #aaa;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* DPS Graph */
        .dps-graph-container {
            height: 150px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        .dps-graph {
            width: 100%;
            height: 100%;
        }

        /* Config Inputs */
        .config-group {
            margin-bottom: 20px;
        }

        .config-item {
            margin-bottom: 12px;
        }

        .config-item label {
            display: block;
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .config-item input[type="number"],
        .config-item select {
            width: 100%;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            transition: all 0.2s;
        }

        .config-item input[type="number"]:focus,
        .config-item select:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.3);
        }

        /* Control Buttons */
        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-start {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(76,175,80,0.4);
        }

        .btn-stop {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            color: white;
        }

        .btn-stop:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(244,67,54,0.4);
        }

        .btn-reset {
            background: linear-gradient(135deg, #ff9800, #f57c00);
            color: white;
        }

        /* Rotation Helper */
        .rotation-helper {
            background: rgba(0,255,0,0.1);
            border: 1px solid rgba(0,255,0,0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
        }

        .rotation-helper h4 {
            color: #00ff00;
            margin-bottom: 10px;
            font-size: 0.9em;
            text-transform: uppercase;
        }

        .next-ability {
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            padding: 8px;
            text-align: center;
        }

        .next-ability-name {
            color: #ffd700;
            font-weight: bold;
            font-size: 1.1em;
        }

        .next-ability-reason {
            color: #aaa;
            font-size: 0.85em;
            margin-top: 5px;
        }

        /* Stats Display */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #444;
            transition: all 0.2s;
        }

        .stat-item:hover {
            border-left-color: #ffd700;
            background: rgba(255,215,0,0.05);
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            color: #ffd700;
            font-weight: bold;
            font-size: 1.1em;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,215,0,0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,215,0,0.5);
        }

        /* Hit Effects */
        .hit-effect {
            position: absolute;
            width: 150px;
            height: 150px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .slash-effect {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent 40%, rgba(255,235,59,0.8) 50%, transparent 60%);
            animation: slashAnimation 0.3s ease-out;
        }

        @keyframes slashAnimation {
            0% {
                transform: rotate(-45deg) scale(0);
                opacity: 1;
            }
            100% {
                transform: rotate(-45deg) scale(2);
                opacity: 0;
            }
        }

        /* Timer Display */
        .combat-timer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.5);
            padding: 5px 20px;
            border-radius: 8px;
        }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>⚔️ ROGUE DPS SIMULATOR ⚔️</h1>
        </div>

        <div class="game-layout">
            <!-- Left Panel - Configuration -->
            <div class="panel">
                <h3>⚙️ Configuration</h3>
                
                <div class="control-buttons">
                    <button class="btn btn-start" id="startBtn">Start</button>
                    <button class="btn btn-stop" id="stopBtn" style="display:none">Stop</button>
                    <button class="btn btn-reset" id="resetBtn">Reset</button>
                </div>

                <div class="config-group">
                    <div class="config-item">
                        <label>Fight Duration (seconds)</label>
                        <input type="number" id="fightDuration" value="60" min="10" max="300">
                    </div>
                    <div class="config-item">
                        <label>Global Cooldown (seconds)</label>
                        <input type="number" id="gcdDuration" value="1.5" min="0.5" max="2.5" step="0.1">
                    </div>
                </div>

                <div class="config-group">
                    <h4 style="color:#ffd700; margin-bottom:10px;">⚔️ Weapon</h4>
                    <div class="config-item">
                        <label>Attack Speed (seconds)</label>
                        <input type="number" id="weaponSpeed" value="2.5" min="1.0" max="4.0" step="0.1">
                    </div>
                    <div class="config-item">
                        <label>Min Damage</label>
                        <input type="number" id="minDamage" value="100" min="1" max="1000">
                    </div>
                    <div class="config-item">
                        <label>Max Damage</label>
                        <input type="number" id="maxDamage" value="200" min="1" max="1000">
                    </div>
                    <div class="config-item">
                        <label>Crit Chance (%)</label>
                        <input type="number" id="critChance" value="25" min="0" max="100">
                    </div>
                </div>

                <div class="config-group">
                    <h4 style="color:#ffd700; margin-bottom:10px;">⚡ Energy</h4>
                    <div class="config-item">
                        <label>Energy Tick Rate (sec)</label>
                        <input type="number" id="energyTickRate" value="2.0" min="0.5" max="3.0" step="0.1">
                    </div>
                    <div class="config-item">
                        <label>Energy per Tick</label>
                        <input type="number" id="energyPerTick" value="20" min="1" max="50">
                    </div>
                    <div class="config-item">
                        <label>Combat Potency (%)</label>
                        <input type="number" id="combatPotency" value="20" min="0" max="100">
                    </div>
                </div>

                <div class="config-group">
                    <h4 style="color:#ffd700; margin-bottom:10px;">🎯 Talents</h4>
                    <div class="config-item">
                        <label>
                            <input type="checkbox" id="relentlessStrikes"> Relentless Strikes
                        </label>
                    </div>
                    <div class="config-item">
                        <label>
                            <input type="checkbox" id="sealFate"> Seal Fate (Auto-crit CP)
                        </label>
                    </div>
                </div>
            </div>

            <!-- Center - Combat Area -->
            <div class="panel combat-area">
                <div class="combat-timer" id="combatTimer" style="display:none">0:00</div>
                
                <div class="buffs-container" id="buffsContainer"></div>

                <div class="target-dummy">
                    <div class="dummy-health-container">
                        <div class="dummy-health-bar" id="dummyHealthBar" style="width:100%"></div>
                        <div class="dummy-health-text" id="dummyHealthText">100%</div>
                    </div>
                    <div class="dummy-model" id="dummyModel">
                        <div class="dummy-head"></div>
                    </div>
                </div>

                <div class="player-resources">
                    <div class="resource-bar">
                        <div class="energy-container">
                            <div class="energy-bar" id="energyBar" style="width:100%"></div>
                            <div class="energy-text" id="energyText">100/100</div>
                        </div>
                    </div>
                    <div class="combo-points-display" id="comboPointsDisplay">
                        <div class="combo-point"></div>
                        <div class="combo-point"></div>
                        <div class="combo-point"></div>
                        <div class="combo-point"></div>
                        <div class="combo-point"></div>
                    </div>
                    <div class="buff-duration-bar-container" id="sndBarContainer" style="display: none;">
                        <div class="buff-duration-bar" id="sndBar"></div>
                        <div class="buff-duration-text" id="sndText">Slice and Dice</div>
                    </div>
                </div>

                <div class="action-bar" id="actionBar">
                    <!-- Abilities will be generated here -->
                </div>
            </div>

            <!-- Right Panel - Stats & Logs -->
            <div class="panel">
                <h3>📊 Combat Stats</h3>
                
                <div class="dps-display">
                    <div class="dps-value" id="currentDPS">0</div>
                    <div class="dps-label">Current DPS</div>
                </div>

                <div class="dps-graph-container">
                    <canvas class="dps-graph" id="dpsGraph"></canvas>
                </div>

                <div class="rotation-helper">
                    <h4>💡 Rotation Helper</h4>
                    <div class="next-ability">
                        <div class="next-ability-name" id="nextAbility">-</div>
                        <div class="next-ability-reason" id="nextAbilityReason">Start combat to see suggestions</div>
                    </div>
                </div>

                <div style="margin-top:20px">
                    <h4 style="color:#ffd700; margin-bottom:10px;">📈 Statistics</h4>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Total Damage</div>
                            <div class="stat-value" id="totalDamage">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Avg DPS</div>
                            <div class="stat-value" id="avgDPS">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Crits</div>
                            <div class="stat-value" id="critCount">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Hit Count</div>
                            <div class="stat-value" id="hitCount">0</div>
                        </div>
                    </div>
                </div>

                <div style="margin-top:20px">
                    <h4 style="color:#ffd700; margin-bottom:10px;">📜 Combat Log</h4>
                    <div class="combat-log" id="combatLog"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game Engine Class
        class RogueSimulator {
            constructor() {
                this.state = {
                    inCombat: false,
                    energy: 100,
                    maxEnergy: 100,
                    comboPoints: 0,
                    maxComboPoints: 5,
                    globalCooldown: 0,
                    dummyHealth: 1000000,
                    dummyMaxHealth: 1000000,
                    buffs: new Map(),
                    cooldowns: new Map(),
                    stats: {
                        totalDamage: 0,
                        hitCount: 0,
                        critCount: 0,
                        startTime: 0,
                        combatTime: 0,
                        dpsHistory: [],
                        abilityUsage: new Map()
                    }
                };

                this.config = {};
                this.timers = {};
                this.abilities = this.initializeAbilities();
                
                this.init();
            }

            initializeAbilities() {
                return {
                    sinisterStrike: {
                        name: 'Sinister Strike',
                        icon: 'SS',
                        energyCost: 40,
                        description: 'A vicious strike that deals damage and awards 1 combo point.',
                        cooldown: 0,
                        damage: () => this.rollDamage(150, 250),
                        critChance: 25,
                        comboPoints: 1,
                        hotkey: '1'
                    },
                    backstab: {
                        name: 'Backstab',
                        icon: 'BS',
                        energyCost: 60,
                        description: 'Stab the target from behind, dealing high damage. Awards 1 combo point.',
                        cooldown: 0,
                        damage: () => this.rollDamage(300, 500),
                        critChance: 30,
                        comboPoints: 1,
                        hotkey: '2'
                    },
                    eviscerate: {
                        name: 'Eviscerate',
                        icon: 'EVI',
                        energyCost: 35,
                        description: 'Finishing move that deals immediate physical damage based on combo points.',
                        cooldown: 0,
                        damage: () => this.rollDamage(100 * this.state.comboPoints, 200 * this.state.comboPoints),
                        critChance: 30,
                        isFinisher: true,
                        hotkey: '3'
                    },
                    sliceAndDice: {
                        name: 'Slice and Dice',
                        icon: 'SnD',
                        energyCost: 25,
                        description: 'Finishing move that increases attack speed. Duration increases per combo point.',
                        cooldown: 0,
                        isFinisher: true,
                        buff: {
                            name: 'Slice and Dice',
                            duration: () => 6 + (3 * this.state.comboPoints),
                            effect: 'attackSpeed',
                            value: 0.3
                        },
                        hotkey: '4'
                    },
                    bladeFlurry: {
                        name: 'Blade Flurry',
                        icon: 'BF',
                        energyCost: 25,
                        description: 'Your attacks have a chance to strike an additional time for 15 sec.',
                        cooldown: 120,
                        buff: {
                            name: 'Blade Flurry',
                            duration: () => 15,
                            effect: 'extraHit',
                            value: 0.2
                        },
                        hotkey: '5'
                    },
                    adrenalineRush: {
                        name: 'Adrenaline Rush',
                        icon: 'AR',
                        energyCost: 0,
                        description: 'Increases your Energy regeneration rate by 100% for 15 sec.',
                        cooldown: 180,
                        buff: {
                            name: 'Adrenaline Rush',
                            duration: () => 15,
                            effect: 'energyRegen',
                            value: 2.0
                        },
                        hotkey: '6'
                    },
                    rupture: {
                        name: 'Rupture',
                        icon: 'RUP',
                        energyCost: 25,
                        description: 'Finishing move that causes Bleed damage over time. Lasts longer per combo point.',
                        cooldown: 0,
                        isFinisher: true,
                        debuff: {
                            name: 'Rupture',
                            duration: () => 6 + (2 * this.state.comboPoints),
                            tickDamage: () => this.rollDamage(50 * this.state.comboPoints, 75 * this.state.comboPoints),
                            tickRate: 2
                        },
                        hotkey: '7'
                    },
                    exposeArmor: {
                        name: 'Expose Armor',
                        icon: 'EA',
                        energyCost: 25,
                        description: "Finishing move that reduces the target's armor. Lasts longer per combo point.",
                        cooldown: 0,
                        isFinisher: true,
                        debuff: {
                            name: 'Expose Armor',
                            duration: () => 30,
                            effect: 'armorReduction',
                            value: 0.2
                        },
                        hotkey: '8'
                    }
                };
            }

            init() {
                this.loadConfig();
                this.setupUI();
                this.bindEvents();
                this.createActionBar();
            }

            loadConfig() {
                this.config = {
                    fightDuration: 60,
                    gcdDuration: 1.5,
                    weaponSpeed: 2.5,
                    minDamage: 100,
                    maxDamage: 200,
                    critChance: 25,
                    energyTickRate: 2.0,
                    energyPerTick: 20,
                    combatPotency: 20,
                    relentlessStrikes: false,
                    sealFate: false
                };
            }

            setupUI() {
                this.ui = {
                    energyBar: document.getElementById('energyBar'),
                    energyText: document.getElementById('energyText'),
                    comboPoints: document.querySelectorAll('.combo-point'),
                    dummyHealthBar: document.getElementById('dummyHealthBar'),
                    dummyHealthText: document.getElementById('dummyHealthText'),
                    dummyModel: document.getElementById('dummyModel'),
                    combatLog: document.getElementById('combatLog'),
                    currentDPS: document.getElementById('currentDPS'),
                    totalDamage: document.getElementById('totalDamage'),
                    avgDPS: document.getElementById('avgDPS'),
                    critCount: document.getElementById('critCount'),
                    hitCount: document.getElementById('hitCount'),
                    combatTimer: document.getElementById('combatTimer'),
                    buffsContainer: document.getElementById('buffsContainer'),
                    nextAbility: document.getElementById('nextAbility'),
                    nextAbilityReason: document.getElementById('nextAbilityReason'),
                    sndBarContainer: document.getElementById('sndBarContainer'),
                    sndBar: document.getElementById('sndBar'),
                    sndText: document.getElementById('sndText')
                };

                this.setupDPSGraph();
            }

            setupDPSGraph() {
                const canvas = document.getElementById('dpsGraph');
                this.dpsGraphCtx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            bindEvents() {
                document.getElementById('startBtn').addEventListener('click', () => this.startCombat());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopCombat());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                // Keyboard hotkeys
                document.addEventListener('keydown', (e) => {
                    if (!this.state.inCombat) return;
                    
                    const slot = document.querySelector(`[data-hotkey="${e.key}"]`);
                    if (slot) {
                        const abilityKey = slot.dataset.ability;
                        this.useAbility(abilityKey);
                    }
                });

                // Config changes
                ['fightDuration', 'gcdDuration', 'weaponSpeed', 'minDamage', 'maxDamage', 
                 'critChance', 'energyTickRate', 'energyPerTick', 'combatPotency'].forEach(id => {
                    document.getElementById(id).addEventListener('change', (e) => {
                        const value = parseFloat(e.target.value) || 0;
                        if (value >= 0) {
                            this.config[id] = value;
                        } else {
                            e.target.value = this.config[id];
                        }
                    });
                });

                document.getElementById('relentlessStrikes').addEventListener('change', (e) => {
                    this.config.relentlessStrikes = e.target.checked;
                });

                document.getElementById('sealFate').addEventListener('change', (e) => {
                    this.config.sealFate = e.target.checked;
                });
            }

            createActionBar() {
                const actionBar = document.getElementById('actionBar');
                actionBar.innerHTML = '';

                Object.entries(this.abilities).forEach(([key, ability]) => {
                    const slot = document.createElement('div');
                    slot.className = 'ability-slot';
                    slot.dataset.ability = key;
                    slot.dataset.hotkey = ability.hotkey;
                    
                    slot.innerHTML = `
                        <div class="ability-tooltip">
                            <div class="tooltip-header">${ability.name}</div>
                            <div class="tooltip-cost">${ability.energyCost > 0 ? `${ability.energyCost} Energy` : 'No Cost'}</div>
                            <div class="tooltip-desc">${ability.description}</div>
                        </div>
                        <div class="ability-icon">${ability.icon}</div>
                        <div class="ability-cost">${ability.energyCost > 0 ? ability.energyCost : ''}</div>
                        <div class="ability-hotkey">${ability.hotkey}</div>
                        <div class="gcd-indicator" id="gcd-${key}"></div>
                    `;
                    
                    slot.addEventListener('click', () => this.useAbility(key));
                    actionBar.appendChild(slot);
                });
            }

            startCombat() {
                this.updateConfig();
                this.state.inCombat = true;
                this.state.stats.startTime = Date.now();
                this.state.energy = this.state.maxEnergy;
                this.state.comboPoints = 0;
                
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'block';
                this.ui.combatTimer.style.display = 'block';

                this.addLogEntry('Combat started!', 'system');
                
                this.startTimers();
                this.updateUI();
            }

            stopCombat() {
                this.state.inCombat = false;
                
                Object.values(this.timers).forEach(timer => clearInterval(timer));
                this.timers = {};
                
                document.getElementById('startBtn').style.display = 'block';
                document.getElementById('stopBtn').style.display = 'none';
                this.ui.combatTimer.style.display = 'none';

                this.addLogEntry('Combat ended!', 'system');
                this.showCombatSummary();
            }

            reset() {
                this.stopCombat();
                this.state = {
                    inCombat: false,
                    energy: 100,
                    maxEnergy: 100,
                    comboPoints: 0,
                    maxComboPoints: 5,
                    globalCooldown: 0,
                    dummyHealth: 1000000,
                    dummyMaxHealth: 1000000,
                    buffs: new Map(),
                    cooldowns: new Map(),
                    stats: {
                        totalDamage: 0,
                        hitCount: 0,
                        critCount: 0,
                        startTime: 0,
                        combatTime: 0,
                        dpsHistory: [],
                        abilityUsage: new Map()
                    }
                };
                this.ui.combatLog.innerHTML = '';
                this.ui.sndBarContainer.style.display = 'none';
                this.updateUI();
            }

            updateConfig() {
                Object.keys(this.config).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        if (element.type === 'checkbox') {
                            this.config[key] = element.checked;
                        } else {
                            this.config[key] = parseFloat(element.value) || 0;
                        }
                    }
                });
            }

            startTimers() {
                // Main combat timer
                this.timers.combat = setInterval(() => {
                    this.state.stats.combatTime++;
                    this.updateCombatTimer();
                    
                    if (this.state.stats.combatTime >= this.config.fightDuration) {
                        this.stopCombat();
                    }
                }, 1000);

                // Auto attack timer
                this.timers.autoAttack = setInterval(() => {
                    this.performAutoAttack();
                }, this.getAttackSpeed() * 1000);

                // Energy regeneration
                this.timers.energy = setInterval(() => {
                    this.regenerateEnergy();
                }, this.config.energyTickRate * 1000);

                // DPS calculation
                this.timers.dps = setInterval(() => {
                    this.calculateDPS();
                }, 100);

                // Buff/Debuff ticks
                this.timers.effects = setInterval(() => {
                    this.tickEffects();
                }, 100);

                // GCD timer
                this.timers.gcd = setInterval(() => {
                    this.updateGCD();
                }, 100);

                // Rotation helper
                this.timers.rotation = setInterval(() => {
                    this.updateRotationHelper();
                }, 500);
            }

            getAttackSpeed() {
                let speed = this.config.weaponSpeed;
                const sndBuff = this.state.buffs.get('Slice and Dice');
                if (sndBuff) {
                    speed *= (1 - sndBuff.value);
                }
                return speed;
            }

            performAutoAttack() {
                if (!this.state.inCombat) return;

                const damage = this.rollDamage(this.config.minDamage, this.config.maxDamage);
                const isCrit = this.rollCrit(this.config.critChance);
                const finalDamage = isCrit ? damage * 2 : damage;

                this.dealDamage(finalDamage, 'Auto Attack', isCrit);

                // Combat Potency proc
                if (Math.random() * 100 < this.config.combatPotency) {
                    this.gainEnergy(15);
                    this.addLogEntry('+15 Energy from Combat Potency', 'energy');
                }

                // Blade Flurry extra hit
                const bfBuff = this.state.buffs.get('Blade Flurry');
                if (bfBuff && Math.random() < bfBuff.value) {
                    const extraDamage = Math.floor(finalDamage * 0.5);
                    this.dealDamage(extraDamage, 'Blade Flurry', false);
                }
            }

            useAbility(abilityKey) {
                if (!this.state.inCombat) return;
                if (this.state.globalCooldown > 0) return;

                const ability = this.abilities[abilityKey];
                if (!ability) return;

                const slot = document.querySelector(`[data-ability="${abilityKey}"]`);

                // Check cooldown
                if (this.state.cooldowns.has(abilityKey)) {
                    slot.classList.add('on-cooldown');
                    return;
                }

                // Check finisher requirements
                if (ability.isFinisher && this.state.comboPoints === 0) {
                    this.flashError(slot, 'Need combo points!');
                    return;
                }

                // Check energy
                if (this.state.energy < ability.energyCost) {
                    slot.classList.add('no-resources');
                    setTimeout(() => slot.classList.remove('no-resources'), 200);
                    return;
                }

                // Use ability
                this.state.energy -= ability.energyCost;
                slot.classList.add('activated');
                setTimeout(() => slot.classList.remove('activated'), 300);

                // Track usage
                const usage = this.state.stats.abilityUsage.get(ability.name) || { count: 0, damage: 0 };
                usage.count++;
                this.state.stats.abilityUsage.set(ability.name, usage);

                let isCrit = false;

                // Apply ability effects
                if (ability.damage) {
                    const damage = ability.damage();
                    isCrit = this.rollCrit(ability.critChance || 25);
                    let finalDamage = isCrit ? damage * 2 : damage;

                    // Expose Armor bonus
                    if (this.state.buffs.has('Expose Armor')) {
                        finalDamage *= 1.2;
                    }

                    this.dealDamage(finalDamage, ability.name, isCrit, true);
                    usage.damage += finalDamage;
                }

                // Generate combo points
                if (ability.comboPoints) {
                    this.gainComboPoints(ability.comboPoints, isCrit);
                }

                // Apply buffs
                if (ability.buff) {
                    this.applyBuff(ability.buff);
                }

                // Apply debuffs
                if (ability.debuff) {
                    this.applyDebuff(ability.debuff);
                }

                // Consume combo points (finishers)
                if (ability.isFinisher) {
                    // Relentless Strikes talent
                    if (this.config.relentlessStrikes) {
                        const chance = this.state.comboPoints * 4;
                        if (Math.random() * 100 < chance) {
                            this.gainEnergy(25);
                            this.addLogEntry('+25 Energy from Relentless Strikes', 'energy');
                        }
                    }
                    this.state.comboPoints = 0;
                }

                // Set cooldown
                if (ability.cooldown > 0) {
                    this.setCooldown(abilityKey, ability.cooldown);
                }

                // Trigger GCD
                this.triggerGCD();
                this.updateUI();
            }

            gainComboPoints(amount, wasCrit) {
                let points = amount;
                
                // Seal Fate talent - crit gives extra combo point
                if (this.config.sealFate && wasCrit) {
                    points++;
                    this.addLogEntry('+1 Combo Point from Seal Fate', 'combo');
                }

                this.state.comboPoints = Math.min(this.state.maxComboPoints, this.state.comboPoints + points);
            }

            applyBuff(buffConfig) {
                const buff = {
                    name: buffConfig.name,
                    duration: buffConfig.duration(),
                    maxDuration: buffConfig.duration(),
                    effect: buffConfig.effect,
                    value: buffConfig.value
                };

                this.state.buffs.set(buff.name, buff);
                this.addLogEntry(`${buff.name} activated (${buff.duration}s)`, 'buff');
                this.updateBuffDisplay();
            }

            applyDebuff(debuffConfig) {
                const debuff = {
                    name: debuffConfig.name,
                    duration: debuffConfig.duration(),
                    maxDuration: debuffConfig.duration(),
                    ...debuffConfig
                };

                this.state.buffs.set(debuff.name, debuff);
                this.addLogEntry(`${debuff.name} applied (${debuff.duration}s)`, 'debuff');
                
                if (debuff.tickDamage) {
                    debuff.nextTick = Date.now() + (debuff.tickRate * 1000);
                }
                
                this.updateBuffDisplay();
            }

            tickEffects() {
                const now = Date.now();
                
                for (const [name, effect] of this.state.buffs) {
                    effect.duration -= 0.1;
                    
                    // Handle DoT ticks
                    if (effect.tickDamage && effect.nextTick && now >= effect.nextTick) {
                        const damage = effect.tickDamage();
                        this.dealDamage(damage, `${name} (tick)`, false);
                        effect.nextTick = now + (effect.tickRate * 1000);
                    }
                    
                    if (effect.duration <= 0) {
                        this.state.buffs.delete(name);
                        this.addLogEntry(`${name} expired`, 'buff');
                        this.updateBuffDisplay();
                    }
                }
                this.updateBuffBars();
            }

            updateBuffDisplay() {
                this.ui.buffsContainer.innerHTML = '';
                
                for (const [name, buff] of this.state.buffs) {
                    const buffDiv = document.createElement('div');
                    buffDiv.className = 'buff-icon';
                    buffDiv.innerHTML = `
                        <div style="color:#fff; font-size:10px; text-align:center; margin-top:8px">
                            ${name.substring(0,3).toUpperCase()}
                        </div>
                        <div class="buff-duration">${Math.ceil(buff.duration)}s</div>
                    `;
                    this.ui.buffsContainer.appendChild(buffDiv);
                }
            }
            
            updateBuffBars() {
                const sndBuff = this.state.buffs.get('Slice and Dice');
                if (sndBuff) {
                    const remainingPercent = (sndBuff.duration / sndBuff.maxDuration) * 100;
                    this.ui.sndBarContainer.style.display = 'block';
                    this.ui.sndBar.style.width = `${remainingPercent}%`;
                    this.ui.sndText.textContent = `Slice and Dice (${Math.ceil(sndBuff.duration)}s)`;
                } else {
                    this.ui.sndBarContainer.style.display = 'none';
                }
            }

            setCooldown(abilityKey, duration) {
                this.state.cooldowns.set(abilityKey, duration);
                const slot = document.querySelector(`[data-ability="${abilityKey}"]`);
                slot.classList.add('on-cooldown');

                const updateCooldown = () => {
                    const remaining = this.state.cooldowns.get(abilityKey);
                    if (!remaining || remaining <= 0) {
                        this.state.cooldowns.delete(abilityKey);
                        slot.classList.remove('on-cooldown');
                        const cdText = slot.querySelector('.cooldown-text');
                        if (cdText) cdText.remove();
                        const cdSweep = slot.querySelector('.cooldown-sweep');
                        if (cdSweep) cdSweep.remove();
                        return;
                    }

                    let cdText = slot.querySelector('.cooldown-text');
                    if (!cdText) {
                        cdText = document.createElement('div');
                        cdText.className = 'cooldown-text';
                        slot.appendChild(cdText);
                        
                        const cdSweep = document.createElement('div');
                        cdSweep.className = 'cooldown-sweep';
                        slot.appendChild(cdSweep);
                    }

                    cdText.textContent = Math.ceil(remaining);
                    this.state.cooldowns.set(abilityKey, remaining - 0.1);
                    setTimeout(updateCooldown, 100);
                };

                updateCooldown();
            }

            triggerGCD() {
                this.state.globalCooldown = this.config.gcdDuration;
                
                document.querySelectorAll('.ability-slot').forEach(slot => {
                    const indicator = slot.querySelector('.gcd-indicator');
                    indicator.style.width = '100%';
                    indicator.style.transition = `width ${this.config.gcdDuration}s linear`;
                    
                    setTimeout(() => {
                        indicator.style.width = '0';
                    }, 50);
                });
            }

            updateGCD() {
                if (this.state.globalCooldown > 0) {
                    this.state.globalCooldown -= 0.1;
                    if (this.state.globalCooldown < 0) {
                        this.state.globalCooldown = 0;
                    }
                }
            }

            regenerateEnergy() {
                let amount = this.config.energyPerTick;
                
                const arBuff = this.state.buffs.get('Adrenaline Rush');
                if (arBuff) {
                    amount *= arBuff.value;
                }

                this.gainEnergy(amount);
            }

            gainEnergy(amount) {
                this.state.energy = Math.min(this.state.maxEnergy, this.state.energy + amount);
                this.updateUI();
            }

            dealDamage(damage, source, isCrit, isSpecial = false) {
                if (!this.state.inCombat) return;

                this.state.stats.totalDamage += damage;
                this.state.stats.hitCount++;
                if (isCrit) this.state.stats.critCount++;

                this.state.dummyHealth = Math.max(0, this.state.dummyHealth - damage);

                this.showFloatingDamage(damage, isCrit, isSpecial);
                this.hitDummy();
                this.addLogEntry(`${source}: ${damage}${isCrit ? ' CRIT!' : ''}`, isCrit ? 'crit' : isSpecial ? 'ability' : 'normal');

                if (isSpecial) {
                    this.showSlashEffect();
                }

                this.updateUI();
            }

            showFloatingDamage(damage, isCrit, isSpecial) {
                const dummy = this.ui.dummyModel;
                const rect = dummy.getBoundingClientRect();
                
                const text = document.createElement('div');
                text.className = 'floating-text';
                
                if (isCrit) {
                    text.classList.add('damage-crit');
                    text.textContent = damage + '!';
                } else if (isSpecial) {
                    text.classList.add('damage-yellow');
                    text.textContent = damage;
                } else {
                    text.classList.add('damage-normal');
                    text.textContent = damage;
                }

                const x = rect.left + rect.width / 2 + (Math.random() * 100 - 50);
                const y = rect.top + rect.height / 2;
                
                text.style.left = x + 'px';
                text.style.top = y + 'px';
                text.style.position = 'fixed';

                document.body.appendChild(text);
                setTimeout(() => text.remove(), 2000);
            }

            showSlashEffect() {
                const dummy = this.ui.dummyModel;
                const effect = document.createElement('div');
                effect.className = 'hit-effect';
                effect.innerHTML = '<div class="slash-effect"></div>';
                dummy.appendChild(effect);
                setTimeout(() => effect.remove(), 300);
            }

            hitDummy() {
                this.ui.dummyModel.classList.add('hit');
                setTimeout(() => this.ui.dummyModel.classList.remove('hit'), 200);
            }

            flashError(element, message) {
                element.style.borderColor = '#ff4444';
                setTimeout(() => element.style.borderColor = '', 500);
            }

            addLogEntry(message, type = 'normal') {
                const time = new Date().toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                });
                
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.innerHTML = `<span class="log-timestamp">[${time}]</span> ${message}`;
                
                this.ui.combatLog.insertBefore(entry, this.ui.combatLog.firstChild);
                
                // Keep log size manageable
                while (this.ui.combatLog.children.length > 100) {
                    this.ui.combatLog.removeChild(this.ui.combatLog.lastChild);
                }
            }

            calculateDPS() {
                const combatTime = (Date.now() - this.state.stats.startTime) / 1000;
                if (combatTime <= 0) return;

                const currentDPS = Math.floor(this.state.stats.totalDamage / combatTime);
                this.state.stats.dpsHistory.push(currentDPS);
                
                // Keep history size manageable
                if (this.state.stats.dpsHistory.length > 100) {
                    this.state.stats.dpsHistory.shift();
                }

                this.ui.currentDPS.textContent = currentDPS;
                this.ui.avgDPS.textContent = currentDPS;
                
                this.updateDPSGraph();
            }

            updateDPSGraph() {
                const canvas = this.dpsGraphCtx.canvas;
                const ctx = this.dpsGraphCtx;
                const history = this.state.stats.dpsHistory;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (history.length < 2) return;
                
                const maxDPS = Math.max(...history) * 1.1;
                const stepX = canvas.width / (history.length - 1);
                
                // Draw grid
                ctx.strokeStyle = 'rgba(255,215,0,0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = (canvas.height / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Draw DPS line
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.shadowColor = 'rgba(255,215,0,0.5)';
                ctx.shadowBlur = 10;
                
                ctx.beginPath();
                history.forEach((dps, i) => {
                    const x = i * stepX;
                    const y = canvas.height - (dps / maxDPS * canvas.height);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Fill area under line
                ctx.fillStyle = 'rgba(255,215,0,0.1)';
                ctx.lineTo(canvas.width, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.closePath();
                ctx.fill();
            }

            updateRotationHelper() {
                if (!this.state.inCombat) return;

                let suggestion = '';
                let reason = '';

                // Priority system for rotation
                if (!this.state.buffs.has('Slice and Dice') && this.state.comboPoints >= 1) {
                    suggestion = 'Slice and Dice';
                    reason = 'Apply attack speed buff';
                } else if (this.state.comboPoints === 5) {
                    if (this.state.buffs.has('Expose Armor')) {
                        suggestion = 'Eviscerate';
                        reason = 'Max combo points - burst damage';
                    } else {
                        suggestion = 'Expose Armor';
                        reason = 'Apply armor reduction';
                    }
                } else if (this.state.energy >= 60 && this.state.comboPoints < 5) {
                    suggestion = 'Backstab';
                    reason = 'Build combo points';
                } else if (this.state.energy >= 40 && this.state.comboPoints < 5) {
                    suggestion = 'Sinister Strike';
                    reason = 'Build combo points';
                } else if (!this.state.cooldowns.has('adrenalineRush') && this.state.energy < 40) {
                    suggestion = 'Adrenaline Rush';
                    reason = 'Low energy - boost regen';
                } else {
                    suggestion = 'Wait';
                    reason = 'Pooling energy';
                }

                this.ui.nextAbility.textContent = suggestion;
                this.ui.nextAbilityReason.textContent = reason;
            }

            updateCombatTimer() {
                const minutes = Math.floor(this.state.stats.combatTime / 60);
                const seconds = this.state.stats.combatTime % 60;
                this.ui.combatTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            showCombatSummary() {
                const combatTime = this.state.stats.combatTime || 1;
                const avgDPS = Math.floor(this.state.stats.totalDamage / combatTime);
                const critRate = this.state.stats.hitCount > 0 
                    ? ((this.state.stats.critCount / this.state.stats.hitCount) * 100).toFixed(1)
                    : 0;

                let summary = `
                    === COMBAT SUMMARY ===
                    Duration: ${combatTime}s
                    Total Damage: ${this.state.stats.totalDamage}
                    Average DPS: ${avgDPS}
                    Crit Rate: ${critRate}%
                    
                    Ability Usage:
                `;

                for (const [name, usage] of this.state.stats.abilityUsage) {
                    summary += `\n    ${name}: ${usage.count}x (${usage.damage} damage)`;
                }

                console.log(summary);
                this.addLogEntry('=== COMBAT SUMMARY ===', 'system');
                this.addLogEntry(`Duration: ${combatTime}s | DPS: ${avgDPS} | Crit: ${critRate}%`, 'system');
            }

            updateUI() {
                // Energy
                const energyPercent = (this.state.energy / this.state.maxEnergy) * 100;
                this.ui.energyBar.style.width = `${energyPercent}%`;
                this.ui.energyText.textContent = `${Math.floor(this.state.energy)}/${this.state.maxEnergy}`;

                // Combo points
                this.ui.comboPoints.forEach((point, index) => {
                    if (index < this.state.comboPoints) {
                        point.classList.add('active');
                    } else {
                        point.classList.remove('active');
                    }
                });

                // Dummy health
                const healthPercent = (this.state.dummyHealth / this.state.dummyMaxHealth) * 100;
                this.ui.dummyHealthBar.style.width = `${healthPercent}%`;
                this.ui.dummyHealthText.textContent = `${healthPercent.toFixed(1)}%`;

                // Stats
                this.ui.totalDamage.textContent = this.state.stats.totalDamage.toLocaleString();
                this.ui.hitCount.textContent = this.state.stats.hitCount;
                this.ui.critCount.textContent = this.state.stats.critCount;
            }

            rollDamage(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            rollCrit(chance) {
                return Math.random() * 100 < chance;
            }
        }

        // Initialize simulator
        const simulator = new RogueSimulator();
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>